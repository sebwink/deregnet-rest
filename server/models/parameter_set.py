# coding: utf-8

from __future__ import absolute_import
from datetime import date, datetime  # noqa: F401

from typing import List, Dict  # noqa: F401

from deregnet_rest.models.base_model_ import Model
from deregnet_rest import util


class ParameterSet(Model):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    def __init__(self, default_score: float=None, flip_orientation: bool=None, num_suboptimal: int=None, max_overlap: float=None, gap_cut: float=None, min_size: int=None, max_size: int=None, abs_values: bool=None, model_sense: str=None, algorithm: str=None, time_limit: int=None):  # noqa: E501
        """ParameterSet - a model defined in Swagger

        :param default_score: The default_score of this ParameterSet.  # noqa: E501
        :type default_score: float
        :param flip_orientation: The flip_orientation of this ParameterSet.  # noqa: E501
        :type flip_orientation: bool
        :param num_suboptimal: The num_suboptimal of this ParameterSet.  # noqa: E501
        :type num_suboptimal: int
        :param max_overlap: The max_overlap of this ParameterSet.  # noqa: E501
        :type max_overlap: float
        :param gap_cut: The gap_cut of this ParameterSet.  # noqa: E501
        :type gap_cut: float
        :param min_size: The min_size of this ParameterSet.  # noqa: E501
        :type min_size: int
        :param max_size: The max_size of this ParameterSet.  # noqa: E501
        :type max_size: int
        :param abs_values: The abs_values of this ParameterSet.  # noqa: E501
        :type abs_values: bool
        :param model_sense: The model_sense of this ParameterSet.  # noqa: E501
        :type model_sense: str
        :param algorithm: The algorithm of this ParameterSet.  # noqa: E501
        :type algorithm: str
        :param time_limit: The time_limit of this ParameterSet.  # noqa: E501
        :type time_limit: int
        """
        self.swagger_types = {
            'default_score': float,
            'flip_orientation': bool,
            'num_suboptimal': int,
            'max_overlap': float,
            'gap_cut': float,
            'min_size': int,
            'max_size': int,
            'abs_values': bool,
            'model_sense': str,
            'algorithm': str,
            'time_limit': int
        }

        self.attribute_map = {
            'default_score': 'default_score',
            'flip_orientation': 'flip_orientation',
            'num_suboptimal': 'num_suboptimal',
            'max_overlap': 'max_overlap',
            'gap_cut': 'gap_cut',
            'min_size': 'min_size',
            'max_size': 'max_size',
            'abs_values': 'abs_values',
            'model_sense': 'model_sense',
            'algorithm': 'algorithm',
            'time_limit': 'time_limit'
        }

        self._default_score = default_score
        self._flip_orientation = flip_orientation
        self._num_suboptimal = num_suboptimal
        self._max_overlap = max_overlap
        self._gap_cut = gap_cut
        self._min_size = min_size
        self._max_size = max_size
        self._abs_values = abs_values
        self._model_sense = model_sense
        self._algorithm = algorithm
        self._time_limit = time_limit

    @classmethod
    def from_dict(cls, dikt) -> 'ParameterSet':
        """Returns the dict as a model

        :param dikt: A dict.
        :type: dict
        :return: The ParameterSet of this ParameterSet.  # noqa: E501
        :rtype: ParameterSet
        """
        return util.deserialize_model(dikt, cls)

    @property
    def default_score(self) -> float:
        """Gets the default_score of this ParameterSet.

        Score of graph node when not defined in node score  # noqa: E501

        :return: The default_score of this ParameterSet.
        :rtype: float
        """
        return self._default_score

    @default_score.setter
    def default_score(self, default_score: float):
        """Sets the default_score of this ParameterSet.

        Score of graph node when not defined in node score  # noqa: E501

        :param default_score: The default_score of this ParameterSet.
        :type default_score: float
        """

        self._default_score = default_score

    @property
    def flip_orientation(self) -> bool:
        """Gets the flip_orientation of this ParameterSet.

        Find a deregulated subgraph upstream of a terminal (root)  # noqa: E501

        :return: The flip_orientation of this ParameterSet.
        :rtype: bool
        """
        return self._flip_orientation

    @flip_orientation.setter
    def flip_orientation(self, flip_orientation: bool):
        """Sets the flip_orientation of this ParameterSet.

        Find a deregulated subgraph upstream of a terminal (root)  # noqa: E501

        :param flip_orientation: The flip_orientation of this ParameterSet.
        :type flip_orientation: bool
        """

        self._flip_orientation = flip_orientation

    @property
    def num_suboptimal(self) -> int:
        """Gets the num_suboptimal of this ParameterSet.

        Number of suboptimal subgraphs to find  # noqa: E501

        :return: The num_suboptimal of this ParameterSet.
        :rtype: int
        """
        return self._num_suboptimal

    @num_suboptimal.setter
    def num_suboptimal(self, num_suboptimal: int):
        """Sets the num_suboptimal of this ParameterSet.

        Number of suboptimal subgraphs to find  # noqa: E501

        :param num_suboptimal: The num_suboptimal of this ParameterSet.
        :type num_suboptimal: int
        """
        if num_suboptimal is not None and num_suboptimal < 0:  # noqa: E501
            raise ValueError("Invalid value for `num_suboptimal`, must be a value greater than or equal to `0`")  # noqa: E501

        self._num_suboptimal = num_suboptimal

    @property
    def max_overlap(self) -> float:
        """Gets the max_overlap of this ParameterSet.

        Maximal overlap (node percentage) of two subgraphs  # noqa: E501

        :return: The max_overlap of this ParameterSet.
        :rtype: float
        """
        return self._max_overlap

    @max_overlap.setter
    def max_overlap(self, max_overlap: float):
        """Sets the max_overlap of this ParameterSet.

        Maximal overlap (node percentage) of two subgraphs  # noqa: E501

        :param max_overlap: The max_overlap of this ParameterSet.
        :type max_overlap: float
        """
        if max_overlap is not None and max_overlap > 100:  # noqa: E501
            raise ValueError("Invalid value for `max_overlap`, must be a value less than or equal to `100`")  # noqa: E501
        if max_overlap is not None and max_overlap < 0:  # noqa: E501
            raise ValueError("Invalid value for `max_overlap`, must be a value greater than or equal to `0`")  # noqa: E501

        self._max_overlap = max_overlap

    @property
    def gap_cut(self) -> float:
        """Gets the gap_cut of this ParameterSet.

        Gap cut to stop optimization prematurely when the best solution found so far is within <Gap cut> * 100 percent of the best possible solution. Best found solutions are accessible as subgraphs.   # noqa: E501

        :return: The gap_cut of this ParameterSet.
        :rtype: float
        """
        return self._gap_cut

    @gap_cut.setter
    def gap_cut(self, gap_cut: float):
        """Sets the gap_cut of this ParameterSet.

        Gap cut to stop optimization prematurely when the best solution found so far is within <Gap cut> * 100 percent of the best possible solution. Best found solutions are accessible as subgraphs.   # noqa: E501

        :param gap_cut: The gap_cut of this ParameterSet.
        :type gap_cut: float
        """
        if gap_cut is not None and gap_cut > 1:  # noqa: E501
            raise ValueError("Invalid value for `gap_cut`, must be a value less than or equal to `1`")  # noqa: E501
        if gap_cut is not None and gap_cut < 0:  # noqa: E501
            raise ValueError("Invalid value for `gap_cut`, must be a value greater than or equal to `0`")  # noqa: E501

        self._gap_cut = gap_cut

    @property
    def min_size(self) -> int:
        """Gets the min_size of this ParameterSet.

        Minimal size of a subgraph (number of nodes)  # noqa: E501

        :return: The min_size of this ParameterSet.
        :rtype: int
        """
        return self._min_size

    @min_size.setter
    def min_size(self, min_size: int):
        """Sets the min_size of this ParameterSet.

        Minimal size of a subgraph (number of nodes)  # noqa: E501

        :param min_size: The min_size of this ParameterSet.
        :type min_size: int
        """
        if min_size is not None and min_size < 0:  # noqa: E501
            raise ValueError("Invalid value for `min_size`, must be a value greater than or equal to `0`")  # noqa: E501

        self._min_size = min_size

    @property
    def max_size(self) -> int:
        """Gets the max_size of this ParameterSet.

        Maximal size of a subgraph (number of nodes)  # noqa: E501

        :return: The max_size of this ParameterSet.
        :rtype: int
        """
        return self._max_size

    @max_size.setter
    def max_size(self, max_size: int):
        """Sets the max_size of this ParameterSet.

        Maximal size of a subgraph (number of nodes)  # noqa: E501

        :param max_size: The max_size of this ParameterSet.
        :type max_size: int
        """
        if max_size is not None and max_size < 0:  # noqa: E501
            raise ValueError("Invalid value for `max_size`, must be a value greater than or equal to `0`")  # noqa: E501

        self._max_size = max_size

    @property
    def abs_values(self) -> bool:
        """Gets the abs_values of this ParameterSet.

        Whether to take the absolute values of the provided scores as actual scores in the computation   # noqa: E501

        :return: The abs_values of this ParameterSet.
        :rtype: bool
        """
        return self._abs_values

    @abs_values.setter
    def abs_values(self, abs_values: bool):
        """Sets the abs_values of this ParameterSet.

        Whether to take the absolute values of the provided scores as actual scores in the computation   # noqa: E501

        :param abs_values: The abs_values of this ParameterSet.
        :type abs_values: bool
        """

        self._abs_values = abs_values

    @property
    def model_sense(self) -> str:
        """Gets the model_sense of this ParameterSet.

        'max' means maximization, 'min' means minimization.  Suitability depends on the semantics of the node scores   # noqa: E501

        :return: The model_sense of this ParameterSet.
        :rtype: str
        """
        return self._model_sense

    @model_sense.setter
    def model_sense(self, model_sense: str):
        """Sets the model_sense of this ParameterSet.

        'max' means maximization, 'min' means minimization.  Suitability depends on the semantics of the node scores   # noqa: E501

        :param model_sense: The model_sense of this ParameterSet.
        :type model_sense: str
        """
        allowed_values = ["max", "min"]  # noqa: E501
        if model_sense not in allowed_values:
            raise ValueError(
                "Invalid value for `model_sense` ({0}), must be one of {1}"
                .format(model_sense, allowed_values)
            )

        self._model_sense = model_sense

    @property
    def algorithm(self) -> str:
        """Gets the algorithm of this ParameterSet.

        Which algorithm to use: gcc: Generalized Charnes-Cooper transform (recommended) dta: Dinkelbach-type algorithm ovt: Objective-Variable transform   # noqa: E501

        :return: The algorithm of this ParameterSet.
        :rtype: str
        """
        return self._algorithm

    @algorithm.setter
    def algorithm(self, algorithm: str):
        """Sets the algorithm of this ParameterSet.

        Which algorithm to use: gcc: Generalized Charnes-Cooper transform (recommended) dta: Dinkelbach-type algorithm ovt: Objective-Variable transform   # noqa: E501

        :param algorithm: The algorithm of this ParameterSet.
        :type algorithm: str
        """
        allowed_values = ["dta", "gcc", "ovt"]  # noqa: E501
        if algorithm not in allowed_values:
            raise ValueError(
                "Invalid value for `algorithm` ({0}), must be one of {1}"
                .format(algorithm, allowed_values)
            )

        self._algorithm = algorithm

    @property
    def time_limit(self) -> int:
        """Gets the time_limit of this ParameterSet.

        Time limit in second. A run is aborted if the limit is reached, in case there were feasible solutions found you can access those as subgraphs though   # noqa: E501

        :return: The time_limit of this ParameterSet.
        :rtype: int
        """
        return self._time_limit

    @time_limit.setter
    def time_limit(self, time_limit: int):
        """Sets the time_limit of this ParameterSet.

        Time limit in second. A run is aborted if the limit is reached, in case there were feasible solutions found you can access those as subgraphs though   # noqa: E501

        :param time_limit: The time_limit of this ParameterSet.
        :type time_limit: int
        """
        if time_limit is not None and time_limit < 0:  # noqa: E501
            raise ValueError("Invalid value for `time_limit`, must be a value greater than or equal to `0`")  # noqa: E501

        self._time_limit = time_limit
